/* automatically generated by rust-bindgen 0.72.0 */

pub const LAB126_LOG_INFO: u32 = 8388608;
pub const LAB126_LOG_WARNING: u32 = 16777216;
pub const LAB126_LOG_ERROR: u32 = 33554432;
pub const LAB126_LOG_CRITICAL: u32 = 67108864;
pub const LAB126_LOG_DEBUG_ALL: u32 = 65280;
pub const LAB126_LOG_ALL: u32 = 4294967040;
pub type __gnuc_va_list = __builtin_va_list;
pub type va_list = __builtin_va_list;
pub type wchar_t = ::std::os::raw::c_int;
#[repr(C)]
#[repr(align(16))]
#[derive(Debug, Copy, Clone)]
pub struct max_align_t {
    pub __clang_max_align_nonce1: ::std::os::raw::c_longlong,
    pub __bindgen_padding_0: u64,
    pub __clang_max_align_nonce2: u128,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of max_align_t"][::std::mem::size_of::<max_align_t>() - 32usize];
    ["Alignment of max_align_t"][::std::mem::align_of::<max_align_t>() - 16usize];
    ["Offset of field: max_align_t::__clang_max_align_nonce1"]
        [::std::mem::offset_of!(max_align_t, __clang_max_align_nonce1) - 0usize];
    ["Offset of field: max_align_t::__clang_max_align_nonce2"]
        [::std::mem::offset_of!(max_align_t, __clang_max_align_nonce2) - 16usize];
};
#[doc = " LIPC library handler."]
pub type LIPC = ::std::os::raw::c_void;
pub const LIPCcode_LIPC_OK: LIPCcode = 0;
pub const LIPCcode_LIPC_ERROR_UNKNOWN: LIPCcode = 1;
pub const LIPCcode_LIPC_ERROR_INTERNAL: LIPCcode = 2;
pub const LIPCcode_LIPC_ERROR_NO_SUCH_SOURCE: LIPCcode = 3;
pub const LIPCcode_LIPC_ERROR_OPERATION_NOT_SUPPORTED: LIPCcode = 4;
pub const LIPCcode_LIPC_ERROR_OUT_OF_MEMORY: LIPCcode = 5;
pub const LIPCcode_LIPC_ERROR_SUBSCRIPTION_FAILED: LIPCcode = 6;
pub const LIPCcode_LIPC_ERROR_NO_SUCH_PARAM: LIPCcode = 7;
pub const LIPCcode_LIPC_ERROR_NO_SUCH_PROPERTY: LIPCcode = 8;
pub const LIPCcode_LIPC_ERROR_ACCESS_NOT_ALLOWED: LIPCcode = 9;
pub const LIPCcode_LIPC_ERROR_BUFFER_TOO_SMALL: LIPCcode = 10;
pub const LIPCcode_LIPC_ERROR_INVALID_HANDLE: LIPCcode = 11;
pub const LIPCcode_LIPC_ERROR_INVALID_ARG: LIPCcode = 12;
pub const LIPCcode_LIPC_ERROR_OPERATION_NOT_ALLOWED: LIPCcode = 13;
pub const LIPCcode_LIPC_ERROR_PARAMS_SIZE_EXCEEDED: LIPCcode = 14;
pub const LIPCcode_LIPC_ERROR_TIMED_OUT: LIPCcode = 15;
pub const LIPCcode_LIPC_ERROR_SERVICE_NAME_TOO_LONG: LIPCcode = 16;
pub const LIPCcode_LIPC_ERROR_DUPLICATE_SERVICE_NAME: LIPCcode = 17;
pub const LIPCcode_LIPC_ERROR_INIT_DBUS: LIPCcode = 18;
pub const LIPCcode_LIPC_PROP_ERROR_INVALID_STATE: LIPCcode = 256;
pub const LIPCcode_LIPC_PROP_ERROR_NOT_INITIALIZED: LIPCcode = 257;
pub const LIPCcode_LIPC_PROP_ERROR_INTERNAL: LIPCcode = 258;
#[doc = " Status codes returned by all sorts of LIPC library functions.\n\n @warning\n This list was obtained from the LipcGetErrorString() function and may\n be not complete - be prepared for other values as well."]
pub type LIPCcode = ::std::os::raw::c_uint;
unsafe extern "C" {
    #[doc = " Initialize LIPC library without registering a new service.\n\n @return On success the LIPC library handler is returned, which should be\n   closed with the LipcClose(). Upon error this function returns NULL."]
    pub fn LipcOpenNoName() -> *mut LIPC;
}
unsafe extern "C" {
    #[doc = " Initialize LIPC library and register a new service.\n\n @param service The service name which should be registered. The name has\n   to be a fully qualified dot-separated identifier, e.g. \"org.MyService\".\n @return On success the LIPC library handler is returned, which should be\n   closed with the LipcClose(). Upon error this function returns NULL."]
    pub fn LipcOpen(service: *const ::std::os::raw::c_char) -> *mut LIPC;
}
unsafe extern "C" {
    #[doc = " Initialize LIPC library and register a new service.\n\n This function is an extended version of the LipcOpen().\n\n @param service The service name which should be registered. The name has\n   to be a fully qualified dot-separated identifier, e.g. \"org.MyService\".\n @param code If not NULL, the status code will be stored in this argument.\n @return On success the LIPC library handler is returned, which should be\n   closed with the LipcClose(). Upon error this function returns NULL."]
    pub fn LipcOpenEx(service: *const ::std::os::raw::c_char, code: *mut LIPCcode) -> *mut LIPC;
}
unsafe extern "C" {
    #[doc = " Close the LIPC handler and release all associated resources.\n\n @param lipc LIPC library handler."]
    pub fn LipcClose(lipc: *mut LIPC);
}
unsafe extern "C" {
    #[doc = " Get the service name associated with the LIPC handler.\n\n @param lipc LIPC library handler.\n @return The service name which was registered during LIPC opening or NULL\n   if the handler was obtained by the call to the LipcOpenNoName()."]
    pub fn LipcGetServiceName(lipc: *mut LIPC) -> *const ::std::os::raw::c_char;
}
unsafe extern "C" {
    #[doc = " Get status code in the string format.\n\n @param code The status code.\n @return String with the human-readable status."]
    pub fn LipcGetErrorString(code: LIPCcode) -> *const ::std::os::raw::c_char;
}
#[doc = " LIPC hash-array handler."]
pub type LIPCha = ::std::os::raw::c_void;
pub const LIPCHasharrayType_LIPC_HASHARRAY_INT: LIPCHasharrayType = 0;
pub const LIPCHasharrayType_LIPC_HASHARRAY_STRING: LIPCHasharrayType = 1;
pub const LIPCHasharrayType_LIPC_HASHARRAY_BLOB: LIPCHasharrayType = 2;
#[doc = " Possible data types, which can be stored in the value of the hash component\n in the hash-array data structure."]
pub type LIPCHasharrayType = ::std::os::raw::c_uint;
unsafe extern "C" {
    #[doc = " Initialize new hash-array data structure.\n\n @param lipc LIPC library handler.\n @return The LIPC hash-array handler or NULL upon error."]
    pub fn LipcHasharrayNew(lipc: *mut LIPC) -> *mut LIPCha;
}
unsafe extern "C" {
    #[doc = " Free resources associated with the hash-array handler.\n\n @param ha The LIPC hash-array handler.\n @param destroy If TRUE, the underlying shared memory segment will be marked\n   to be destroyed.\n @return The status code."]
    pub fn LipcHasharrayFree(ha: *mut LIPCha, destroy: ::std::os::raw::c_int) -> LIPCcode;
}
unsafe extern "C" {
    #[doc = " Free resources associated with the hash-array handler.\n\n This function is an equivalent of calling the LipcHasharrayFree() function\n with the destroy parameter set to TRUE.\n\n @param ha The LIPC hash-array handler.\n @return The status code."]
    pub fn LipcHasharrayDestroy(ha: *mut LIPCha) -> LIPCcode;
}
unsafe extern "C" {
    #[doc = " Get the number of elements in the array component of the hash-array data\n structure.\n\n @param ha The LIPC hash-array handler.\n @return The array size or -1 upon error."]
    pub fn LipcHasharrayGetHashCount(ha: *mut LIPCha) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Append new hash map to the hash-array structure.\n\n @param ha The LIPC hash-array handler.\n @param index The address where the index of newly added hash map (hence,\n   the size of the array) will be stored.\n @return The status code."]
    pub fn LipcHasharrayAddHash(ha: *mut LIPCha, index: *mut usize) -> LIPCcode;
}
unsafe extern "C" {
    #[doc = " Get keys stored in the hash map of the hash-array data structure.\n\n In order to determine the number of keys at the given index, one should\n call this function with the count parameter initialized to 0. The number\n of available keys will be returned back in this parameter - in fact the\n count parameter is always modified, and the number of keys is returned in\n it (be careful when reusing this variable for iteration over keys array).\n\n @param ha The LIPC hash-array handler.\n @param index The 0-based index in the array.\n @param keys The array which can store up to the count number of string\n   pointers - keys.\n @param count The address where the number of keys to fetch is given.\n @return The status code."]
    pub fn LipcHasharrayKeys(
        ha: *mut LIPCha,
        index: ::std::os::raw::c_int,
        keys: *mut *const ::std::os::raw::c_char,
        count: *mut usize,
    ) -> LIPCcode;
}
unsafe extern "C" {
    #[doc = " Get the data type stored in the hash map of the hash-array data structure.\n\n @param ha The LIPC hash-array handler.\n @param index The 0-based index in the array.\n @param key The key name to check.\n @param type The address where the data type will be stored.\n @param size The address where the size of the value will be stored.\n @return The status code."]
    pub fn LipcHasharrayCheckKey(
        ha: *mut LIPCha,
        index: ::std::os::raw::c_int,
        key: *const ::std::os::raw::c_char,
        type_: *mut LIPCHasharrayType,
        size: *mut usize,
    ) -> LIPCcode;
}
unsafe extern "C" {
    #[doc = " Get the integer value form the hash map of the hash-array data structure.\n\n @param ha The LIPC hash-array handler.\n @param index The 0-based index in the array.\n @param key The key name to get.\n @param value The address where the integer value will be stored.\n @return The status code."]
    pub fn LipcHasharrayGetInt(
        ha: *mut LIPCha,
        index: ::std::os::raw::c_int,
        key: *const ::std::os::raw::c_char,
        value: *mut ::std::os::raw::c_int,
    ) -> LIPCcode;
}
unsafe extern "C" {
    #[doc = " Put the integer value into the hash map of the hash-array data structure.\n\n @param ha The LIPC hash-array handler.\n @param index The 0-based index in the array.\n @param key The key name to set.\n @param value The value to set.\n @return The status code."]
    pub fn LipcHasharrayPutInt(
        ha: *mut LIPCha,
        index: ::std::os::raw::c_int,
        key: *const ::std::os::raw::c_char,
        value: ::std::os::raw::c_int,
    ) -> LIPCcode;
}
unsafe extern "C" {
    #[doc = " Get the string value form the hash map of the hash-array data structure.\n\n @param ha The LIPC hash-array handler.\n @param index The 0-based index in the array.\n @param key The key name to get.\n @param value The address where the pointer to the string will be stored.\n @return The status code."]
    pub fn LipcHasharrayGetString(
        ha: *mut LIPCha,
        index: ::std::os::raw::c_int,
        key: *const ::std::os::raw::c_char,
        value: *mut *mut ::std::os::raw::c_char,
    ) -> LIPCcode;
}
unsafe extern "C" {
    #[doc = " Put the string value into the hash map of the hash-array data structure.\n\n @param ha The LIPC hash-array handler.\n @param index The 0-based index in the array.\n @param key The key name to set.\n @param value The value to set.\n @return The status code."]
    pub fn LipcHasharrayPutString(
        ha: *mut LIPCha,
        index: ::std::os::raw::c_int,
        key: *const ::std::os::raw::c_char,
        value: *const ::std::os::raw::c_char,
    ) -> LIPCcode;
}
unsafe extern "C" {
    #[doc = " Get the blob data from the hash map of the hash-array data structure.\n\n @param ha The LIPC hash-array handler.\n @param index The 0-based index in the array.\n @param key The key name to get.\n @param data The address where the pointer to the data will be stored.\n @param size The address where the size of the data will be stored.\n @return The status code."]
    pub fn LipcHasharrayGetBlob(
        ha: *mut LIPCha,
        index: ::std::os::raw::c_int,
        key: *const ::std::os::raw::c_char,
        data: *mut *mut ::std::os::raw::c_uchar,
        size: *mut usize,
    ) -> LIPCcode;
}
unsafe extern "C" {
    #[doc = " Put the blob data into the hash map of the hash-array data structure.\n\n @param ha The LIPC hash-array handler.\n @param index The 0-based index in the array.\n @param key The key name to set.\n @param data The data to set.\n @param size The size of the data.\n @return The status code."]
    pub fn LipcHasharrayPutBlob(
        ha: *mut LIPCha,
        index: ::std::os::raw::c_int,
        key: *const ::std::os::raw::c_char,
        data: *const ::std::os::raw::c_uchar,
        size: usize,
    ) -> LIPCcode;
}
unsafe extern "C" {
    #[doc = " Copy a hash-array data structure.\n\n The destination hash-array structure handler has to be initialized with the\n LipcHasharrayNew() function.\n\n @param dest The destination hash-array handler.\n @param src The source hash-array handler.\n @return The status code."]
    pub fn LipcHasharrayCopy(dest: *mut LIPCha, src: *const LIPCha) -> LIPCcode;
}
unsafe extern "C" {
    #[doc = " Copy a single hash map of the hash-array data structure.\n\n The destination hash-array structure handler has to be initialized with the\n LipcHasharrayNew() function.\n\n @param dest The destination hash-array handler.\n @param dest_index The index in the destination hash-array structure, where\n   the copied hash map will be placed.\n @param src The source hash-array handler.\n @param src_index The index within the source hash-array structure, from\n   where the hash map is copied.\n @return The status code."]
    pub fn LipcHasharrayCopyHash(
        dest: *mut LIPCha,
        dest_index: ::std::os::raw::c_int,
        src: *const LIPCha,
        src_index: ::std::os::raw::c_int,
    ) -> LIPCcode;
}
unsafe extern "C" {
    #[doc = " Clone a hash-array data structure.\n\n This function is (almost) an equivalent of calling the LipcHasharrayCopy()\n function using a newly initialized hash-array handler. However, using this\n function ensures, that the internal hash-array key and few other internal\n fields are copied too. The exact meaning of these fields is unknown.\n\n @param ha The hash-array handler to the structure which should be cloned.\n @return On success the LIPC hash-array handler to the new data structure\n   is returned. Upon error this function returns NULL."]
    pub fn LipcHasharrayClone(ha: *const LIPCha) -> *mut LIPCha;
}
unsafe extern "C" {
    #[doc = " Save hash-array memory into the given file descriptor.\n\n @param ha The hash-array handler.\n @param fd Opened file descriptor with the write permission.\n @return The status code."]
    pub fn LipcHasharraySave(ha: *const LIPCha, fd: ::std::os::raw::c_int) -> LIPCcode;
}
unsafe extern "C" {
    #[doc = " Restore hash-array form the memory read from the given file descriptor.\n\n @param lipc LIPC library handler.\n @param fd Opened file descriptor with the read permission.\n @return On success the LIPC hash-array handler to the restored data\n   structure is returned. Upon error this function returns NULL."]
    pub fn LipcHasharrayRestore(lipc: *mut LIPC, fd: ::std::os::raw::c_int) -> *mut LIPCha;
}
unsafe extern "C" {
    #[doc = " Get string representation of the given hash-array.\n\n In order to determine the number of bytes required to store the string\n representation of the given hash-array data structure, one should call this\n function with the size parameter initialized to 0. The number of required\n bytes will be returned back in this parameter - in fact the size parameter\n is always modified, and the number of required bytes is returned in it (be\n careful when reusing this variable).\n\n @param ha The hash-array handler.\n @param str The pointer to the address, where the hash-array string\n   representation will be stored.\n @param size The pointer to the address, where the size of the str buffer\n   is passed. On return, the number of actually used bytes will be stored\n   at this address.\n @return The status code."]
    pub fn LipcHasharrayToString(
        ha: *const LIPCha,
        str_: *mut ::std::os::raw::c_char,
        size: *mut usize,
    ) -> LIPCcode;
}
unsafe extern "C" {
    #[doc = " Get property access timeout.\n\n @note\n The timeout value can be set via the file \"/var/local/system/lipctimeout\",\n otherwise it is set to the default 10000 ms.\n\n @param lipc LIPC library handler.\n @return The timeout value in milliseconds."]
    pub fn LipcGetPropAccessTimeout(lipc: *mut LIPC) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Get the value of the integer property.\n\n @param lipc LIPC library handler.\n @param service The service name.\n @param property The property name.\n @param value The address where the integer value will be stored.\n @return The status code."]
    pub fn LipcGetIntProperty(
        lipc: *mut LIPC,
        service: *const ::std::os::raw::c_char,
        property: *const ::std::os::raw::c_char,
        value: *mut ::std::os::raw::c_int,
    ) -> LIPCcode;
}
unsafe extern "C" {
    #[doc = " Set the value of the integer property.\n\n @param lipc LIPC library handler.\n @param service The service name.\n @param property The property name.\n @param value The new value to set.\n @return The status code."]
    pub fn LipcSetIntProperty(
        lipc: *mut LIPC,
        service: *const ::std::os::raw::c_char,
        property: *const ::std::os::raw::c_char,
        value: ::std::os::raw::c_int,
    ) -> LIPCcode;
}
unsafe extern "C" {
    #[doc = " Get the value of the string property.\n\n The memory for the returned string is allocated internally by the library\n and should be freed with the LipcFreeString().\n\n @param lipc LIPC library handler.\n @param service The service name.\n @param property The property name.\n @param value The address where the pointer to the string will be stored.\n @return The status code."]
    pub fn LipcGetStringProperty(
        lipc: *mut LIPC,
        service: *const ::std::os::raw::c_char,
        property: *const ::std::os::raw::c_char,
        value: *mut *mut ::std::os::raw::c_char,
    ) -> LIPCcode;
}
unsafe extern "C" {
    #[doc = " Set the value of the string property.\n\n @param lipc LIPC library handler.\n @param service The service name.\n @param property The property name.\n @param value The new value to set.\n @return The status code."]
    pub fn LipcSetStringProperty(
        lipc: *mut LIPC,
        service: *const ::std::os::raw::c_char,
        property: *const ::std::os::raw::c_char,
        value: *const ::std::os::raw::c_char,
    ) -> LIPCcode;
}
unsafe extern "C" {
    #[doc = " Access the value of the hash-array property.\n\n @param lipc LIPC library handler.\n @param service The service name.\n @param property The property name.\n @param ha An input LIPC hash-array handler or NULL if there is no input.\n @param ha_out The pointer to the address, where the output hash-array\n   handler will be stored. If the output value is not desired, one can\n   pass NULL value in this parameter.\n @return The status code."]
    pub fn LipcAccessHasharrayProperty(
        lipc: *mut LIPC,
        service: *const ::std::os::raw::c_char,
        property: *const ::std::os::raw::c_char,
        ha: *const LIPCha,
        ha_out: *mut *mut LIPCha,
    ) -> LIPCcode;
}
unsafe extern "C" {
    #[doc = " Free memory allocated by the LIPC.\n\n @param string The string pointer."]
    pub fn LipcFreeString(string: *mut ::std::os::raw::c_char);
}
#[doc = " Property getter/setter callback function.\n\n This callback function can be used either for getting properties or for\n setting ones. However, there is a slight difference in both actions. Also,\n there is a difference when the callback function is called for getting a\n string, and when it is called for getting an integer.\n\n When the getter is called for the integer property, one has to set the\n address pointed by the *value to the desired integer value.\n\n When the getter is called for the string property, the buffer pointed by\n the *value is preallocated to the initial size. This size is available in\n the *data parameter. If the buffer is too small for storing desired string\n value, one should return the LIPC_ERROR_BUFFER_TOO_SMALL code and pass the\n required buffer size in the *data argument. In such a case, the callback\n function will be called again with the requested buffer size.\n\n When the setter is called, the value parameter contains the integer value\n itself or it points to the memory buffer, respectively for the integer\n property or for the string property.\n\n For convenience, one can use one of the helper macros (LIPC_GETTER_VTOI(),\n LIPC_SETTER_VTOI(), LIPC_GETTER_VTOS() or LIPC_SETTER_VTOS()) for casting\n the value parameter into the proper type based on the callback type.\n\n In all cases, with the exception of the string property getter, the data\n parameter will contain the value passed during the property registration.\n\n The return value of the callback function will be used as a return value\n for the caller, e.g. LipcGetIntProperty(). One exception from this rule is\n a getter for a string property, where the LIPC_ERROR_BUFFER_TOO_SMALL code\n is used internally by the LIPC library.\n\n @param lipc LIPC library handler.\n @param property The property name.\n @param value Pointer to the memory area for a value storage.\n @param data Data passed during property registration.\n @return The status code."]
pub type LipcPropCallback = ::std::option::Option<
    unsafe extern "C" fn(
        lipc: *mut LIPC,
        property: *const ::std::os::raw::c_char,
        value: *mut ::std::os::raw::c_void,
        data: *mut ::std::os::raw::c_void,
    ) -> LIPCcode,
>;
unsafe extern "C" {
    #[doc = " Register new integer property.\n\n The access mode of the property is determined by the presence of the getter\n and/or the setter callback function. Passing NULL value in the getter and\n the setter parameters will make the property read-only, however it will not\n be possible to retrieve any value, so it is pointless to do so.\n\n @param lipc LIPC library handler.\n @param property The property name.\n @param getter Getter callback if property is readable.\n @param setter Setter callback if property is writable.\n @param data Data pointer passed to the callback function.\n @return The status code."]
    pub fn LipcRegisterIntProperty(
        lipc: *mut LIPC,
        property: *const ::std::os::raw::c_char,
        getter: LipcPropCallback,
        setter: LipcPropCallback,
        data: *mut ::std::os::raw::c_void,
    ) -> LIPCcode;
}
unsafe extern "C" {
    #[doc = " Register new string property.\n\n For the information about the property access mode, see the documentation\n of the LipcRegisterIntProperty().\n\n @param lipc LIPC library handler.\n @param property The property name.\n @param getter Getter callback if property is readable.\n @param setter Setter callback if property is writable.\n @param data Data pointer passed to the callback function.\n @return The status code."]
    pub fn LipcRegisterStringProperty(
        lipc: *mut LIPC,
        property: *const ::std::os::raw::c_char,
        getter: LipcPropCallback,
        setter: LipcPropCallback,
        data: *mut ::std::os::raw::c_void,
    ) -> LIPCcode;
}
unsafe extern "C" {
    #[doc = " Register new hash-array property.\n\n @param lipc LIPC library handler.\n @param property The property name.\n @param callback Getter and setter callback function.\n @param data Data pointer passed to the callback function.\n @return The status code."]
    pub fn LipcRegisterHasharrayProperty(
        lipc: *mut LIPC,
        property: *const ::std::os::raw::c_char,
        callback: LipcPropCallback,
        data: *mut ::std::os::raw::c_void,
    ) -> LIPCcode;
}
unsafe extern "C" {
    #[doc = " Unregister property.\n\n If the data parameter is not NULL, the address of the data pointer passed\n during the property registration will be stored in the address pointed by\n the *data.\n\n @param lipc LIPC library handler.\n @param property The property name.\n @param data Address where the data pointer is returned.\n @return The status code."]
    pub fn LipcUnregisterProperty(
        lipc: *mut LIPC,
        property: *const ::std::os::raw::c_char,
        data: *mut *mut ::std::os::raw::c_void,
    ) -> LIPCcode;
}
#[doc = " LIPC event handler."]
pub type LIPCevent = ::std::os::raw::c_void;
unsafe extern "C" {
    #[doc = " Create a new event object.\n\n In order to use this function the LIPC handler has to be opened with the\n service name given using LipcOpen() or LipcOpenEx().\n\n @param lipc LIPC library handler.\n @param name The event name.\n @return On success the LIPCevent handler is returned, which should be freed\n   with the LipcEventFree(). Upon error this function returns NULL."]
    pub fn LipcNewEvent(lipc: *mut LIPC, name: *const ::std::os::raw::c_char) -> *mut LIPCevent;
}
unsafe extern "C" {
    #[doc = " Free memory allocated by the LIPC.\n\n @param event LIPC event handler."]
    pub fn LipcEventFree(event: *mut LIPCevent);
}
unsafe extern "C" {
    #[doc = " Send event object.\n\n @param lipc LIPC library handler.\n @param event LIPC event handler.\n @return The status code."]
    pub fn LipcSendEvent(lipc: *mut LIPC, event: *mut LIPCevent) -> LIPCcode;
}
unsafe extern "C" {
    #[doc = " Create and send event.\n\n This function is an equivalent of using LipcNewEvent(), LipcSendEvent() and\n LipcEventFree() all together. If you want to send a simple event object -\n one without any parameters - use this function.\n\n @param lipc LIPC library handler.\n @param name The event name.\n @return The status code."]
    pub fn LipcCreateAndSendEvent(lipc: *mut LIPC, name: *const ::std::os::raw::c_char)
        -> LIPCcode;
}
unsafe extern "C" {
    #[doc = " Create and send event.\n\n This function creates an event object and sets its parameters according to\n the format string. This function takes variable number of arguments.\n\n LIPC supports two kinds of event parameters: integers and strings. It is\n possible to specify both of these types via the format string in the same\n way the printf() function family does. The format string can contain any\n number of \"%d\" or/and \"%s\" conversion specifiers. It is also possible to\n pass an empty string in the format argument, which will be an equivalent\n of calling the LipcCreateAndSendEvent().\n\n The format string also supports the \".0\" precision modifier. However, its\n purpose is yet to be discovered.\n\n @param lipc LIPC library handler.\n @param name The event name.\n @param format The format string.\n @param ... Variable list of parameters.\n @return The status code."]
    pub fn LipcCreateAndSendEventWithParameters(
        lipc: *mut LIPC,
        name: *const ::std::os::raw::c_char,
        format: *const ::std::os::raw::c_char,
        ...
    ) -> LIPCcode;
}
unsafe extern "C" {
    #[doc = " Create and send event.\n\n This function creates an event object and sets its parameters according to\n the format string. Parameter values should be passed as a variable argument\n list. For the list of all supported formats, see the documentation of the\n LipcCreateAndSendEventWithParameters() function.\n\n @param lipc LIPC library handler.\n @param name The event name.\n @param format The format string.\n @param ap Variable argument list.\n @return The status code."]
    pub fn LipcCreateAndSendEventWithVAListParameters(
        lipc: *mut LIPC,
        name: *const ::std::os::raw::c_char,
        format: *const ::std::os::raw::c_char,
        ap: va_list,
    ) -> LIPCcode;
}
unsafe extern "C" {
    #[doc = " Get the source name associated with the event.\n\n @param event LIPC event handler.\n @return The source name from where the event originates."]
    pub fn LipcGetEventSource(event: *mut LIPCevent) -> *const ::std::os::raw::c_char;
}
unsafe extern "C" {
    #[doc = " Get the name of the event.\n\n @param event LIPC event handler.\n @return The event name."]
    pub fn LipcGetEventName(event: *mut LIPCevent) -> *const ::std::os::raw::c_char;
}
unsafe extern "C" {
    #[doc = " Get the integer parameter from the event.\n\n @param event LIPC event handler.\n @param value The address where the integer value will be stored.\n @return The status code."]
    pub fn LipcGetIntParam(event: *mut LIPCevent, value: *mut ::std::os::raw::c_int) -> LIPCcode;
}
unsafe extern "C" {
    #[doc = " Add the integer parameter to the event.\n\n @param event LIPC event handler.\n @param value The new value to add.\n @return The status code."]
    pub fn LipcAddIntParam(event: *mut LIPCevent, value: ::std::os::raw::c_int) -> LIPCcode;
}
unsafe extern "C" {
    #[doc = " Get the string parameter from the event.\n\n @note\n The obtained memory pointer should not be passed to the LipcFreeString()\n function. It seems, that the memory is managed internally by the library.\n\n @param event LIPC event handler.\n @param value The address where the pointer to the string will be stored.\n @return The status code."]
    pub fn LipcGetStringParam(
        event: *mut LIPCevent,
        value: *mut *mut ::std::os::raw::c_char,
    ) -> LIPCcode;
}
unsafe extern "C" {
    #[doc = " Add the string parameter to the event.\n\n @param event LIPC event handler.\n @param value The new value to add.\n @return The status code."]
    pub fn LipcAddStringParam(
        event: *mut LIPCevent,
        value: *const ::std::os::raw::c_char,
    ) -> LIPCcode;
}
unsafe extern "C" {
    #[doc = " Rewind parameters of the event.\n\n @param event LIPC event handler.\n @return The status code."]
    pub fn LipcRewindParams(event: *mut LIPCevent) -> LIPCcode;
}
#[doc = " Event dispatching callback function.\n\n @param lipc LIPC library handler.\n @param name The event name.\n @param event The LIPC event handler.\n @param data Data pointer passed during subscription.\n @return The status code."]
pub type LipcEventCallback = ::std::option::Option<
    unsafe extern "C" fn(
        lipc: *mut LIPC,
        name: *const ::std::os::raw::c_char,
        event: *mut LIPCevent,
        data: *mut ::std::os::raw::c_void,
    ) -> LIPCcode,
>;
unsafe extern "C" {
    #[doc = " Set default event callback function.\n\n The callback function will be called when one uses the LipcSubscribe()\n subscription mechanism. Note, that it is not possible to pass user-defined\n data via this approach - if one wants to pass extra data to the callback\n function, one should use the LipcSubscribeExt() instead.\n\n @param lipc LIPC library handler.\n @param callback Event dispatching callback function.\n @return The status code."]
    pub fn LipcSetEventCallback(lipc: *mut LIPC, callback: LipcEventCallback) -> LIPCcode;
}
unsafe extern "C" {
    #[doc = " Subscribe for all events emitted by the service.\n\n In order to receive event notifications, one has to set default callback\n function using the LipcSetEventCallback() function. Using them both, is an\n equivalent of using the extended version with parameters set as follows:\n LipcSubscribeExt(lipc, service, NULL, callback, NULL)\n\n @param lipc LIPC library handler.\n @param service The service name.\n @return The status code."]
    pub fn LipcSubscribe(lipc: *mut LIPC, service: *const ::std::os::raw::c_char) -> LIPCcode;
}
unsafe extern "C" {
    #[doc = " Subscribe for events emitted by the service.\n\n This function is an extended version of the LipcSubscribe(), which allows\n to set the event name for which one wants to subscribe and the user-defined\n data passed to the callback function. Passing NULL instead of the event\n name will subscribe for all events.\n\n @param lipc LIPC library handler.\n @param service The service name.\n @param name The event name.\n @param callback Event dispatching callback function.\n @param data Data pointer passed to the callback function.\n @return The status code."]
    pub fn LipcSubscribeExt(
        lipc: *mut LIPC,
        service: *const ::std::os::raw::c_char,
        name: *const ::std::os::raw::c_char,
        callback: LipcEventCallback,
        data: *mut ::std::os::raw::c_void,
    ) -> LIPCcode;
}
unsafe extern "C" {
    #[doc = " Unsubscribe from event or events.\n\n If the event name is NULL, this function will unsubscribe from events\n delivered to the callback set with the LipcSetEventCallback().\n\n @param lipc LIPC library handler.\n @param service The service name.\n @param name The event name or NULL.\n @param data Address where the data pointer is returned or NULL.\n @return The status code."]
    pub fn LipcUnsubscribeExt(
        lipc: *mut LIPC,
        service: *const ::std::os::raw::c_char,
        name: *const ::std::os::raw::c_char,
        data: *mut *mut ::std::os::raw::c_void,
    ) -> LIPCcode;
}
unsafe extern "C" {
    #[doc = " Global logging mask."]
    pub static mut g_lab126_log_mask: ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Set the LIPC internal logging mask.\n\n The logging mask parameter should be the logical OR of the logging flags\n (LAB126_LOG_* definitions). The current state of the logging mask can be\n accessed via the g_lab126_log_mask global variable.\n\n @param mask The logging mask."]
    pub fn LipcSetLlog(mask: ::std::os::raw::c_int);
}
pub type __builtin_va_list = *mut ::std::os::raw::c_void;
