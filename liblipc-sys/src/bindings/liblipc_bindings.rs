#![allow(non_upper_case_globals)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(unused)]
#![allow(unsafe_op_in_unsafe_fn)] // depecrated, but --dynamic-loading hasn't been updated in eons

/* automatically generated by rust-bindgen 0.72.0 */

pub const LAB126_LOG_INFO: u32 = 8388608;
pub const LAB126_LOG_WARNING: u32 = 16777216;
pub const LAB126_LOG_ERROR: u32 = 33554432;
pub const LAB126_LOG_CRITICAL: u32 = 67108864;
pub const LAB126_LOG_DEBUG_ALL: u32 = 65280;
pub const LAB126_LOG_ALL: u32 = 4294967040;
pub type __gnuc_va_list = __builtin_va_list;
pub type va_list = __builtin_va_list;
pub type wchar_t = ::std::os::raw::c_int;
#[repr(C)]
#[repr(align(16))]
#[derive(Debug, Copy, Clone)]
pub struct max_align_t {
    pub __clang_max_align_nonce1: ::std::os::raw::c_longlong,
    pub __bindgen_padding_0: u64,
    pub __clang_max_align_nonce2: u128,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of max_align_t"][::std::mem::size_of::<max_align_t>() - 32usize];
    ["Alignment of max_align_t"][::std::mem::align_of::<max_align_t>() - 16usize];
    ["Offset of field: max_align_t::__clang_max_align_nonce1"]
        [::std::mem::offset_of!(max_align_t, __clang_max_align_nonce1) - 0usize];
    ["Offset of field: max_align_t::__clang_max_align_nonce2"]
        [::std::mem::offset_of!(max_align_t, __clang_max_align_nonce2) - 16usize];
};
#[doc = " LIPC library handler."]
pub type LIPC = ::std::os::raw::c_void;
pub const LIPCcode_LIPC_OK: LIPCcode = 0;
pub const LIPCcode_LIPC_ERROR_UNKNOWN: LIPCcode = 1;
pub const LIPCcode_LIPC_ERROR_INTERNAL: LIPCcode = 2;
pub const LIPCcode_LIPC_ERROR_NO_SUCH_SOURCE: LIPCcode = 3;
pub const LIPCcode_LIPC_ERROR_OPERATION_NOT_SUPPORTED: LIPCcode = 4;
pub const LIPCcode_LIPC_ERROR_OUT_OF_MEMORY: LIPCcode = 5;
pub const LIPCcode_LIPC_ERROR_SUBSCRIPTION_FAILED: LIPCcode = 6;
pub const LIPCcode_LIPC_ERROR_NO_SUCH_PARAM: LIPCcode = 7;
pub const LIPCcode_LIPC_ERROR_NO_SUCH_PROPERTY: LIPCcode = 8;
pub const LIPCcode_LIPC_ERROR_ACCESS_NOT_ALLOWED: LIPCcode = 9;
pub const LIPCcode_LIPC_ERROR_BUFFER_TOO_SMALL: LIPCcode = 10;
pub const LIPCcode_LIPC_ERROR_INVALID_HANDLE: LIPCcode = 11;
pub const LIPCcode_LIPC_ERROR_INVALID_ARG: LIPCcode = 12;
pub const LIPCcode_LIPC_ERROR_OPERATION_NOT_ALLOWED: LIPCcode = 13;
pub const LIPCcode_LIPC_ERROR_PARAMS_SIZE_EXCEEDED: LIPCcode = 14;
pub const LIPCcode_LIPC_ERROR_TIMED_OUT: LIPCcode = 15;
pub const LIPCcode_LIPC_ERROR_SERVICE_NAME_TOO_LONG: LIPCcode = 16;
pub const LIPCcode_LIPC_ERROR_DUPLICATE_SERVICE_NAME: LIPCcode = 17;
pub const LIPCcode_LIPC_ERROR_INIT_DBUS: LIPCcode = 18;
pub const LIPCcode_LIPC_PROP_ERROR_INVALID_STATE: LIPCcode = 256;
pub const LIPCcode_LIPC_PROP_ERROR_NOT_INITIALIZED: LIPCcode = 257;
pub const LIPCcode_LIPC_PROP_ERROR_INTERNAL: LIPCcode = 258;
#[doc = " Status codes returned by all sorts of LIPC library functions.\n\n @warning\n This list was obtained from the LipcGetErrorString() function and may\n be not complete - be prepared for other values as well."]
pub type LIPCcode = ::std::os::raw::c_uint;
#[doc = " LIPC hash-array handler."]
pub type LIPCha = ::std::os::raw::c_void;
pub const LIPCHasharrayType_LIPC_HASHARRAY_INT: LIPCHasharrayType = 0;
pub const LIPCHasharrayType_LIPC_HASHARRAY_STRING: LIPCHasharrayType = 1;
pub const LIPCHasharrayType_LIPC_HASHARRAY_BLOB: LIPCHasharrayType = 2;
#[doc = " Possible data types, which can be stored in the value of the hash component\n in the hash-array data structure."]
pub type LIPCHasharrayType = ::std::os::raw::c_uint;
#[doc = " Property getter/setter callback function.\n\n This callback function can be used either for getting properties or for\n setting ones. However, there is a slight difference in both actions. Also,\n there is a difference when the callback function is called for getting a\n string, and when it is called for getting an integer.\n\n When the getter is called for the integer property, one has to set the\n address pointed by the *value to the desired integer value.\n\n When the getter is called for the string property, the buffer pointed by\n the *value is preallocated to the initial size. This size is available in\n the *data parameter. If the buffer is too small for storing desired string\n value, one should return the LIPC_ERROR_BUFFER_TOO_SMALL code and pass the\n required buffer size in the *data argument. In such a case, the callback\n function will be called again with the requested buffer size.\n\n When the setter is called, the value parameter contains the integer value\n itself or it points to the memory buffer, respectively for the integer\n property or for the string property.\n\n For convenience, one can use one of the helper macros (LIPC_GETTER_VTOI(),\n LIPC_SETTER_VTOI(), LIPC_GETTER_VTOS() or LIPC_SETTER_VTOS()) for casting\n the value parameter into the proper type based on the callback type.\n\n In all cases, with the exception of the string property getter, the data\n parameter will contain the value passed during the property registration.\n\n The return value of the callback function will be used as a return value\n for the caller, e.g. LipcGetIntProperty(). One exception from this rule is\n a getter for a string property, where the LIPC_ERROR_BUFFER_TOO_SMALL code\n is used internally by the LIPC library.\n\n @param lipc LIPC library handler.\n @param property The property name.\n @param value Pointer to the memory area for a value storage.\n @param data Data passed during property registration.\n @return The status code."]
pub type LipcPropCallback = ::std::option::Option<
    unsafe extern "C" fn(
        lipc: *mut LIPC,
        property: *const ::std::os::raw::c_char,
        value: *mut ::std::os::raw::c_void,
        data: *mut ::std::os::raw::c_void,
    ) -> LIPCcode,
>;
#[doc = " LIPC event handler."]
pub type LIPCevent = ::std::os::raw::c_void;
#[doc = " Event dispatching callback function.\n\n @param lipc LIPC library handler.\n @param name The event name.\n @param event The LIPC event handler.\n @param data Data pointer passed during subscription.\n @return The status code."]
pub type LipcEventCallback = ::std::option::Option<
    unsafe extern "C" fn(
        lipc: *mut LIPC,
        name: *const ::std::os::raw::c_char,
        event: *mut LIPCevent,
        data: *mut ::std::os::raw::c_void,
    ) -> LIPCcode,
>;
pub type __builtin_va_list = *mut ::std::os::raw::c_void;
pub struct OPENLIPC {
    __library: ::libloading::Library,
    pub LipcOpenNoName: Result<unsafe extern "C" fn() -> *mut LIPC, ::libloading::Error>,
    pub LipcOpen: Result<
        unsafe extern "C" fn(service: *const ::std::os::raw::c_char) -> *mut LIPC,
        ::libloading::Error,
    >,
    pub LipcOpenEx: Result<
        unsafe extern "C" fn(
            service: *const ::std::os::raw::c_char,
            code: *mut LIPCcode,
        ) -> *mut LIPC,
        ::libloading::Error,
    >,
    pub LipcClose: Result<unsafe extern "C" fn(lipc: *mut LIPC), ::libloading::Error>,
    pub LipcGetServiceName: Result<
        unsafe extern "C" fn(lipc: *mut LIPC) -> *const ::std::os::raw::c_char,
        ::libloading::Error,
    >,
    pub LipcGetErrorString: Result<
        unsafe extern "C" fn(code: LIPCcode) -> *const ::std::os::raw::c_char,
        ::libloading::Error,
    >,
    pub LipcHasharrayNew:
        Result<unsafe extern "C" fn(lipc: *mut LIPC) -> *mut LIPCha, ::libloading::Error>,
    pub LipcHasharrayFree: Result<
        unsafe extern "C" fn(ha: *mut LIPCha, destroy: ::std::os::raw::c_int) -> LIPCcode,
        ::libloading::Error,
    >,
    pub LipcHasharrayDestroy:
        Result<unsafe extern "C" fn(ha: *mut LIPCha) -> LIPCcode, ::libloading::Error>,
    pub LipcHasharrayGetHashCount:
        Result<unsafe extern "C" fn(ha: *mut LIPCha) -> ::std::os::raw::c_int, ::libloading::Error>,
    pub LipcHasharrayAddHash: Result<
        unsafe extern "C" fn(ha: *mut LIPCha, index: *mut usize) -> LIPCcode,
        ::libloading::Error,
    >,
    pub LipcHasharrayKeys: Result<
        unsafe extern "C" fn(
            ha: *mut LIPCha,
            index: ::std::os::raw::c_int,
            keys: *mut *const ::std::os::raw::c_char,
            count: *mut usize,
        ) -> LIPCcode,
        ::libloading::Error,
    >,
    pub LipcHasharrayCheckKey: Result<
        unsafe extern "C" fn(
            ha: *mut LIPCha,
            index: ::std::os::raw::c_int,
            key: *const ::std::os::raw::c_char,
            type_: *mut LIPCHasharrayType,
            size: *mut usize,
        ) -> LIPCcode,
        ::libloading::Error,
    >,
    pub LipcHasharrayGetInt: Result<
        unsafe extern "C" fn(
            ha: *mut LIPCha,
            index: ::std::os::raw::c_int,
            key: *const ::std::os::raw::c_char,
            value: *mut ::std::os::raw::c_int,
        ) -> LIPCcode,
        ::libloading::Error,
    >,
    pub LipcHasharrayPutInt: Result<
        unsafe extern "C" fn(
            ha: *mut LIPCha,
            index: ::std::os::raw::c_int,
            key: *const ::std::os::raw::c_char,
            value: ::std::os::raw::c_int,
        ) -> LIPCcode,
        ::libloading::Error,
    >,
    pub LipcHasharrayGetString: Result<
        unsafe extern "C" fn(
            ha: *mut LIPCha,
            index: ::std::os::raw::c_int,
            key: *const ::std::os::raw::c_char,
            value: *mut *mut ::std::os::raw::c_char,
        ) -> LIPCcode,
        ::libloading::Error,
    >,
    pub LipcHasharrayPutString: Result<
        unsafe extern "C" fn(
            ha: *mut LIPCha,
            index: ::std::os::raw::c_int,
            key: *const ::std::os::raw::c_char,
            value: *const ::std::os::raw::c_char,
        ) -> LIPCcode,
        ::libloading::Error,
    >,
    pub LipcHasharrayGetBlob: Result<
        unsafe extern "C" fn(
            ha: *mut LIPCha,
            index: ::std::os::raw::c_int,
            key: *const ::std::os::raw::c_char,
            data: *mut *mut ::std::os::raw::c_uchar,
            size: *mut usize,
        ) -> LIPCcode,
        ::libloading::Error,
    >,
    pub LipcHasharrayPutBlob: Result<
        unsafe extern "C" fn(
            ha: *mut LIPCha,
            index: ::std::os::raw::c_int,
            key: *const ::std::os::raw::c_char,
            data: *const ::std::os::raw::c_uchar,
            size: usize,
        ) -> LIPCcode,
        ::libloading::Error,
    >,
    pub LipcHasharrayCopy: Result<
        unsafe extern "C" fn(dest: *mut LIPCha, src: *const LIPCha) -> LIPCcode,
        ::libloading::Error,
    >,
    pub LipcHasharrayCopyHash: Result<
        unsafe extern "C" fn(
            dest: *mut LIPCha,
            dest_index: ::std::os::raw::c_int,
            src: *const LIPCha,
            src_index: ::std::os::raw::c_int,
        ) -> LIPCcode,
        ::libloading::Error,
    >,
    pub LipcHasharrayClone:
        Result<unsafe extern "C" fn(ha: *const LIPCha) -> *mut LIPCha, ::libloading::Error>,
    pub LipcHasharraySave: Result<
        unsafe extern "C" fn(ha: *const LIPCha, fd: ::std::os::raw::c_int) -> LIPCcode,
        ::libloading::Error,
    >,
    pub LipcHasharrayRestore: Result<
        unsafe extern "C" fn(lipc: *mut LIPC, fd: ::std::os::raw::c_int) -> *mut LIPCha,
        ::libloading::Error,
    >,
    pub LipcHasharrayToString: Result<
        unsafe extern "C" fn(
            ha: *const LIPCha,
            str_: *mut ::std::os::raw::c_char,
            size: *mut usize,
        ) -> LIPCcode,
        ::libloading::Error,
    >,
    pub LipcGetPropAccessTimeout:
        Result<unsafe extern "C" fn(lipc: *mut LIPC) -> ::std::os::raw::c_int, ::libloading::Error>,
    pub LipcGetIntProperty: Result<
        unsafe extern "C" fn(
            lipc: *mut LIPC,
            service: *const ::std::os::raw::c_char,
            property: *const ::std::os::raw::c_char,
            value: *mut ::std::os::raw::c_int,
        ) -> LIPCcode,
        ::libloading::Error,
    >,
    pub LipcSetIntProperty: Result<
        unsafe extern "C" fn(
            lipc: *mut LIPC,
            service: *const ::std::os::raw::c_char,
            property: *const ::std::os::raw::c_char,
            value: ::std::os::raw::c_int,
        ) -> LIPCcode,
        ::libloading::Error,
    >,
    pub LipcGetStringProperty: Result<
        unsafe extern "C" fn(
            lipc: *mut LIPC,
            service: *const ::std::os::raw::c_char,
            property: *const ::std::os::raw::c_char,
            value: *mut *mut ::std::os::raw::c_char,
        ) -> LIPCcode,
        ::libloading::Error,
    >,
    pub LipcSetStringProperty: Result<
        unsafe extern "C" fn(
            lipc: *mut LIPC,
            service: *const ::std::os::raw::c_char,
            property: *const ::std::os::raw::c_char,
            value: *const ::std::os::raw::c_char,
        ) -> LIPCcode,
        ::libloading::Error,
    >,
    pub LipcAccessHasharrayProperty: Result<
        unsafe extern "C" fn(
            lipc: *mut LIPC,
            service: *const ::std::os::raw::c_char,
            property: *const ::std::os::raw::c_char,
            ha: *const LIPCha,
            ha_out: *mut *mut LIPCha,
        ) -> LIPCcode,
        ::libloading::Error,
    >,
    pub LipcFreeString:
        Result<unsafe extern "C" fn(string: *mut ::std::os::raw::c_char), ::libloading::Error>,
    pub LipcRegisterIntProperty: Result<
        unsafe extern "C" fn(
            lipc: *mut LIPC,
            property: *const ::std::os::raw::c_char,
            getter: LipcPropCallback,
            setter: LipcPropCallback,
            data: *mut ::std::os::raw::c_void,
        ) -> LIPCcode,
        ::libloading::Error,
    >,
    pub LipcRegisterStringProperty: Result<
        unsafe extern "C" fn(
            lipc: *mut LIPC,
            property: *const ::std::os::raw::c_char,
            getter: LipcPropCallback,
            setter: LipcPropCallback,
            data: *mut ::std::os::raw::c_void,
        ) -> LIPCcode,
        ::libloading::Error,
    >,
    pub LipcRegisterHasharrayProperty: Result<
        unsafe extern "C" fn(
            lipc: *mut LIPC,
            property: *const ::std::os::raw::c_char,
            callback: LipcPropCallback,
            data: *mut ::std::os::raw::c_void,
        ) -> LIPCcode,
        ::libloading::Error,
    >,
    pub LipcUnregisterProperty: Result<
        unsafe extern "C" fn(
            lipc: *mut LIPC,
            property: *const ::std::os::raw::c_char,
            data: *mut *mut ::std::os::raw::c_void,
        ) -> LIPCcode,
        ::libloading::Error,
    >,
    pub LipcNewEvent: Result<
        unsafe extern "C" fn(
            lipc: *mut LIPC,
            name: *const ::std::os::raw::c_char,
        ) -> *mut LIPCevent,
        ::libloading::Error,
    >,
    pub LipcEventFree: Result<unsafe extern "C" fn(event: *mut LIPCevent), ::libloading::Error>,
    pub LipcSendEvent: Result<
        unsafe extern "C" fn(lipc: *mut LIPC, event: *mut LIPCevent) -> LIPCcode,
        ::libloading::Error,
    >,
    pub LipcCreateAndSendEvent: Result<
        unsafe extern "C" fn(lipc: *mut LIPC, name: *const ::std::os::raw::c_char) -> LIPCcode,
        ::libloading::Error,
    >,
    pub LipcCreateAndSendEventWithParameters: Result<
        unsafe extern "C" fn(
            lipc: *mut LIPC,
            name: *const ::std::os::raw::c_char,
            format: *const ::std::os::raw::c_char,
            ...
        ) -> LIPCcode,
        ::libloading::Error,
    >,
    pub LipcCreateAndSendEventWithVAListParameters: Result<
        unsafe extern "C" fn(
            lipc: *mut LIPC,
            name: *const ::std::os::raw::c_char,
            format: *const ::std::os::raw::c_char,
            ap: va_list,
        ) -> LIPCcode,
        ::libloading::Error,
    >,
    pub LipcGetEventSource: Result<
        unsafe extern "C" fn(event: *mut LIPCevent) -> *const ::std::os::raw::c_char,
        ::libloading::Error,
    >,
    pub LipcGetEventName: Result<
        unsafe extern "C" fn(event: *mut LIPCevent) -> *const ::std::os::raw::c_char,
        ::libloading::Error,
    >,
    pub LipcGetIntParam: Result<
        unsafe extern "C" fn(event: *mut LIPCevent, value: *mut ::std::os::raw::c_int) -> LIPCcode,
        ::libloading::Error,
    >,
    pub LipcAddIntParam: Result<
        unsafe extern "C" fn(event: *mut LIPCevent, value: ::std::os::raw::c_int) -> LIPCcode,
        ::libloading::Error,
    >,
    pub LipcGetStringParam: Result<
        unsafe extern "C" fn(
            event: *mut LIPCevent,
            value: *mut *mut ::std::os::raw::c_char,
        ) -> LIPCcode,
        ::libloading::Error,
    >,
    pub LipcAddStringParam: Result<
        unsafe extern "C" fn(
            event: *mut LIPCevent,
            value: *const ::std::os::raw::c_char,
        ) -> LIPCcode,
        ::libloading::Error,
    >,
    pub LipcRewindParams:
        Result<unsafe extern "C" fn(event: *mut LIPCevent) -> LIPCcode, ::libloading::Error>,
    pub LipcSetEventCallback: Result<
        unsafe extern "C" fn(lipc: *mut LIPC, callback: LipcEventCallback) -> LIPCcode,
        ::libloading::Error,
    >,
    pub LipcSubscribe: Result<
        unsafe extern "C" fn(lipc: *mut LIPC, service: *const ::std::os::raw::c_char) -> LIPCcode,
        ::libloading::Error,
    >,
    pub LipcSubscribeExt: Result<
        unsafe extern "C" fn(
            lipc: *mut LIPC,
            service: *const ::std::os::raw::c_char,
            name: *const ::std::os::raw::c_char,
            callback: LipcEventCallback,
            data: *mut ::std::os::raw::c_void,
        ) -> LIPCcode,
        ::libloading::Error,
    >,
    pub LipcUnsubscribeExt: Result<
        unsafe extern "C" fn(
            lipc: *mut LIPC,
            service: *const ::std::os::raw::c_char,
            name: *const ::std::os::raw::c_char,
            data: *mut *mut ::std::os::raw::c_void,
        ) -> LIPCcode,
        ::libloading::Error,
    >,
    pub g_lab126_log_mask: Result<*mut ::std::os::raw::c_int, ::libloading::Error>,
    pub LipcSetLlog: Result<unsafe extern "C" fn(mask: ::std::os::raw::c_int), ::libloading::Error>,
}
impl OPENLIPC {
    pub unsafe fn new<P>(path: P) -> Result<Self, ::libloading::Error>
    where
        P: AsRef<::std::ffi::OsStr>,
    {
        let library = ::libloading::Library::new(path)?;
        Self::from_library(library)
    }
    pub unsafe fn from_library<L>(library: L) -> Result<Self, ::libloading::Error>
    where
        L: Into<::libloading::Library>,
    {
        let __library = library.into();
        let LipcOpenNoName = __library.get(b"LipcOpenNoName\0").map(|sym| *sym);
        let LipcOpen = __library.get(b"LipcOpen\0").map(|sym| *sym);
        let LipcOpenEx = __library.get(b"LipcOpenEx\0").map(|sym| *sym);
        let LipcClose = __library.get(b"LipcClose\0").map(|sym| *sym);
        let LipcGetServiceName = __library.get(b"LipcGetServiceName\0").map(|sym| *sym);
        let LipcGetErrorString = __library.get(b"LipcGetErrorString\0").map(|sym| *sym);
        let LipcHasharrayNew = __library.get(b"LipcHasharrayNew\0").map(|sym| *sym);
        let LipcHasharrayFree = __library.get(b"LipcHasharrayFree\0").map(|sym| *sym);
        let LipcHasharrayDestroy = __library.get(b"LipcHasharrayDestroy\0").map(|sym| *sym);
        let LipcHasharrayGetHashCount = __library
            .get(b"LipcHasharrayGetHashCount\0")
            .map(|sym| *sym);
        let LipcHasharrayAddHash = __library.get(b"LipcHasharrayAddHash\0").map(|sym| *sym);
        let LipcHasharrayKeys = __library.get(b"LipcHasharrayKeys\0").map(|sym| *sym);
        let LipcHasharrayCheckKey = __library.get(b"LipcHasharrayCheckKey\0").map(|sym| *sym);
        let LipcHasharrayGetInt = __library.get(b"LipcHasharrayGetInt\0").map(|sym| *sym);
        let LipcHasharrayPutInt = __library.get(b"LipcHasharrayPutInt\0").map(|sym| *sym);
        let LipcHasharrayGetString = __library.get(b"LipcHasharrayGetString\0").map(|sym| *sym);
        let LipcHasharrayPutString = __library.get(b"LipcHasharrayPutString\0").map(|sym| *sym);
        let LipcHasharrayGetBlob = __library.get(b"LipcHasharrayGetBlob\0").map(|sym| *sym);
        let LipcHasharrayPutBlob = __library.get(b"LipcHasharrayPutBlob\0").map(|sym| *sym);
        let LipcHasharrayCopy = __library.get(b"LipcHasharrayCopy\0").map(|sym| *sym);
        let LipcHasharrayCopyHash = __library.get(b"LipcHasharrayCopyHash\0").map(|sym| *sym);
        let LipcHasharrayClone = __library.get(b"LipcHasharrayClone\0").map(|sym| *sym);
        let LipcHasharraySave = __library.get(b"LipcHasharraySave\0").map(|sym| *sym);
        let LipcHasharrayRestore = __library.get(b"LipcHasharrayRestore\0").map(|sym| *sym);
        let LipcHasharrayToString = __library.get(b"LipcHasharrayToString\0").map(|sym| *sym);
        let LipcGetPropAccessTimeout = __library.get(b"LipcGetPropAccessTimeout\0").map(|sym| *sym);
        let LipcGetIntProperty = __library.get(b"LipcGetIntProperty\0").map(|sym| *sym);
        let LipcSetIntProperty = __library.get(b"LipcSetIntProperty\0").map(|sym| *sym);
        let LipcGetStringProperty = __library.get(b"LipcGetStringProperty\0").map(|sym| *sym);
        let LipcSetStringProperty = __library.get(b"LipcSetStringProperty\0").map(|sym| *sym);
        let LipcAccessHasharrayProperty = __library
            .get(b"LipcAccessHasharrayProperty\0")
            .map(|sym| *sym);
        let LipcFreeString = __library.get(b"LipcFreeString\0").map(|sym| *sym);
        let LipcRegisterIntProperty = __library.get(b"LipcRegisterIntProperty\0").map(|sym| *sym);
        let LipcRegisterStringProperty = __library
            .get(b"LipcRegisterStringProperty\0")
            .map(|sym| *sym);
        let LipcRegisterHasharrayProperty = __library
            .get(b"LipcRegisterHasharrayProperty\0")
            .map(|sym| *sym);
        let LipcUnregisterProperty = __library.get(b"LipcUnregisterProperty\0").map(|sym| *sym);
        let LipcNewEvent = __library.get(b"LipcNewEvent\0").map(|sym| *sym);
        let LipcEventFree = __library.get(b"LipcEventFree\0").map(|sym| *sym);
        let LipcSendEvent = __library.get(b"LipcSendEvent\0").map(|sym| *sym);
        let LipcCreateAndSendEvent = __library.get(b"LipcCreateAndSendEvent\0").map(|sym| *sym);
        let LipcCreateAndSendEventWithParameters = __library
            .get(b"LipcCreateAndSendEventWithParameters\0")
            .map(|sym| *sym);
        let LipcCreateAndSendEventWithVAListParameters = __library
            .get(b"LipcCreateAndSendEventWithVAListParameters\0")
            .map(|sym| *sym);
        let LipcGetEventSource = __library.get(b"LipcGetEventSource\0").map(|sym| *sym);
        let LipcGetEventName = __library.get(b"LipcGetEventName\0").map(|sym| *sym);
        let LipcGetIntParam = __library.get(b"LipcGetIntParam\0").map(|sym| *sym);
        let LipcAddIntParam = __library.get(b"LipcAddIntParam\0").map(|sym| *sym);
        let LipcGetStringParam = __library.get(b"LipcGetStringParam\0").map(|sym| *sym);
        let LipcAddStringParam = __library.get(b"LipcAddStringParam\0").map(|sym| *sym);
        let LipcRewindParams = __library.get(b"LipcRewindParams\0").map(|sym| *sym);
        let LipcSetEventCallback = __library.get(b"LipcSetEventCallback\0").map(|sym| *sym);
        let LipcSubscribe = __library.get(b"LipcSubscribe\0").map(|sym| *sym);
        let LipcSubscribeExt = __library.get(b"LipcSubscribeExt\0").map(|sym| *sym);
        let LipcUnsubscribeExt = __library.get(b"LipcUnsubscribeExt\0").map(|sym| *sym);
        let g_lab126_log_mask = __library
            .get::<*mut ::std::os::raw::c_int>(b"g_lab126_log_mask\0")
            .map(|sym| *sym);
        let LipcSetLlog = __library.get(b"LipcSetLlog\0").map(|sym| *sym);
        Ok(OPENLIPC {
            __library,
            LipcOpenNoName,
            LipcOpen,
            LipcOpenEx,
            LipcClose,
            LipcGetServiceName,
            LipcGetErrorString,
            LipcHasharrayNew,
            LipcHasharrayFree,
            LipcHasharrayDestroy,
            LipcHasharrayGetHashCount,
            LipcHasharrayAddHash,
            LipcHasharrayKeys,
            LipcHasharrayCheckKey,
            LipcHasharrayGetInt,
            LipcHasharrayPutInt,
            LipcHasharrayGetString,
            LipcHasharrayPutString,
            LipcHasharrayGetBlob,
            LipcHasharrayPutBlob,
            LipcHasharrayCopy,
            LipcHasharrayCopyHash,
            LipcHasharrayClone,
            LipcHasharraySave,
            LipcHasharrayRestore,
            LipcHasharrayToString,
            LipcGetPropAccessTimeout,
            LipcGetIntProperty,
            LipcSetIntProperty,
            LipcGetStringProperty,
            LipcSetStringProperty,
            LipcAccessHasharrayProperty,
            LipcFreeString,
            LipcRegisterIntProperty,
            LipcRegisterStringProperty,
            LipcRegisterHasharrayProperty,
            LipcUnregisterProperty,
            LipcNewEvent,
            LipcEventFree,
            LipcSendEvent,
            LipcCreateAndSendEvent,
            LipcCreateAndSendEventWithParameters,
            LipcCreateAndSendEventWithVAListParameters,
            LipcGetEventSource,
            LipcGetEventName,
            LipcGetIntParam,
            LipcAddIntParam,
            LipcGetStringParam,
            LipcAddStringParam,
            LipcRewindParams,
            LipcSetEventCallback,
            LipcSubscribe,
            LipcSubscribeExt,
            LipcUnsubscribeExt,
            g_lab126_log_mask,
            LipcSetLlog,
        })
    }
    #[doc = " Initialize LIPC library without registering a new service.\n\n @return On success the LIPC library handler is returned, which should be\n   closed with the LipcClose(). Upon error this function returns NULL."]
    pub unsafe fn LipcOpenNoName(&self) -> *mut LIPC {
        (self
            .LipcOpenNoName
            .as_ref()
            .expect("Expected function, got error."))()
    }
    #[doc = " Initialize LIPC library and register a new service.\n\n @param service The service name which should be registered. The name has\n   to be a fully qualified dot-separated identifier, e.g. \"org.MyService\".\n @return On success the LIPC library handler is returned, which should be\n   closed with the LipcClose(). Upon error this function returns NULL."]
    pub unsafe fn LipcOpen(&self, service: *const ::std::os::raw::c_char) -> *mut LIPC {
        (self
            .LipcOpen
            .as_ref()
            .expect("Expected function, got error."))(service)
    }
    #[doc = " Initialize LIPC library and register a new service.\n\n This function is an extended version of the LipcOpen().\n\n @param service The service name which should be registered. The name has\n   to be a fully qualified dot-separated identifier, e.g. \"org.MyService\".\n @param code If not NULL, the status code will be stored in this argument.\n @return On success the LIPC library handler is returned, which should be\n   closed with the LipcClose(). Upon error this function returns NULL."]
    pub unsafe fn LipcOpenEx(
        &self,
        service: *const ::std::os::raw::c_char,
        code: *mut LIPCcode,
    ) -> *mut LIPC {
        (self
            .LipcOpenEx
            .as_ref()
            .expect("Expected function, got error."))(service, code)
    }
    #[doc = " Close the LIPC handler and release all associated resources.\n\n @param lipc LIPC library handler."]
    pub unsafe fn LipcClose(&self, lipc: *mut LIPC) {
        (self
            .LipcClose
            .as_ref()
            .expect("Expected function, got error."))(lipc)
    }
    #[doc = " Get the service name associated with the LIPC handler.\n\n @param lipc LIPC library handler.\n @return The service name which was registered during LIPC opening or NULL\n   if the handler was obtained by the call to the LipcOpenNoName()."]
    pub unsafe fn LipcGetServiceName(&self, lipc: *mut LIPC) -> *const ::std::os::raw::c_char {
        (self
            .LipcGetServiceName
            .as_ref()
            .expect("Expected function, got error."))(lipc)
    }
    #[doc = " Get status code in the string format.\n\n @param code The status code.\n @return String with the human-readable status."]
    pub unsafe fn LipcGetErrorString(&self, code: LIPCcode) -> *const ::std::os::raw::c_char {
        (self
            .LipcGetErrorString
            .as_ref()
            .expect("Expected function, got error."))(code)
    }
    #[doc = " Initialize new hash-array data structure.\n\n @param lipc LIPC library handler.\n @return The LIPC hash-array handler or NULL upon error."]
    pub unsafe fn LipcHasharrayNew(&self, lipc: *mut LIPC) -> *mut LIPCha {
        (self
            .LipcHasharrayNew
            .as_ref()
            .expect("Expected function, got error."))(lipc)
    }
    #[doc = " Free resources associated with the hash-array handler.\n\n @param ha The LIPC hash-array handler.\n @param destroy If TRUE, the underlying shared memory segment will be marked\n   to be destroyed.\n @return The status code."]
    pub unsafe fn LipcHasharrayFree(
        &self,
        ha: *mut LIPCha,
        destroy: ::std::os::raw::c_int,
    ) -> LIPCcode {
        (self
            .LipcHasharrayFree
            .as_ref()
            .expect("Expected function, got error."))(ha, destroy)
    }
    #[doc = " Free resources associated with the hash-array handler.\n\n This function is an equivalent of calling the LipcHasharrayFree() function\n with the destroy parameter set to TRUE.\n\n @param ha The LIPC hash-array handler.\n @return The status code."]
    pub unsafe fn LipcHasharrayDestroy(&self, ha: *mut LIPCha) -> LIPCcode {
        (self
            .LipcHasharrayDestroy
            .as_ref()
            .expect("Expected function, got error."))(ha)
    }
    #[doc = " Get the number of elements in the array component of the hash-array data\n structure.\n\n @param ha The LIPC hash-array handler.\n @return The array size or -1 upon error."]
    pub unsafe fn LipcHasharrayGetHashCount(&self, ha: *mut LIPCha) -> ::std::os::raw::c_int {
        (self
            .LipcHasharrayGetHashCount
            .as_ref()
            .expect("Expected function, got error."))(ha)
    }
    #[doc = " Append new hash map to the hash-array structure.\n\n @param ha The LIPC hash-array handler.\n @param index The address where the index of newly added hash map (hence,\n   the size of the array) will be stored.\n @return The status code."]
    pub unsafe fn LipcHasharrayAddHash(&self, ha: *mut LIPCha, index: *mut usize) -> LIPCcode {
        (self
            .LipcHasharrayAddHash
            .as_ref()
            .expect("Expected function, got error."))(ha, index)
    }
    #[doc = " Get keys stored in the hash map of the hash-array data structure.\n\n In order to determine the number of keys at the given index, one should\n call this function with the count parameter initialized to 0. The number\n of available keys will be returned back in this parameter - in fact the\n count parameter is always modified, and the number of keys is returned in\n it (be careful when reusing this variable for iteration over keys array).\n\n @param ha The LIPC hash-array handler.\n @param index The 0-based index in the array.\n @param keys The array which can store up to the count number of string\n   pointers - keys.\n @param count The address where the number of keys to fetch is given.\n @return The status code."]
    pub unsafe fn LipcHasharrayKeys(
        &self,
        ha: *mut LIPCha,
        index: ::std::os::raw::c_int,
        keys: *mut *const ::std::os::raw::c_char,
        count: *mut usize,
    ) -> LIPCcode {
        (self
            .LipcHasharrayKeys
            .as_ref()
            .expect("Expected function, got error."))(ha, index, keys, count)
    }
    #[doc = " Get the data type stored in the hash map of the hash-array data structure.\n\n @param ha The LIPC hash-array handler.\n @param index The 0-based index in the array.\n @param key The key name to check.\n @param type The address where the data type will be stored.\n @param size The address where the size of the value will be stored.\n @return The status code."]
    pub unsafe fn LipcHasharrayCheckKey(
        &self,
        ha: *mut LIPCha,
        index: ::std::os::raw::c_int,
        key: *const ::std::os::raw::c_char,
        type_: *mut LIPCHasharrayType,
        size: *mut usize,
    ) -> LIPCcode {
        (self
            .LipcHasharrayCheckKey
            .as_ref()
            .expect("Expected function, got error."))(ha, index, key, type_, size)
    }
    #[doc = " Get the integer value form the hash map of the hash-array data structure.\n\n @param ha The LIPC hash-array handler.\n @param index The 0-based index in the array.\n @param key The key name to get.\n @param value The address where the integer value will be stored.\n @return The status code."]
    pub unsafe fn LipcHasharrayGetInt(
        &self,
        ha: *mut LIPCha,
        index: ::std::os::raw::c_int,
        key: *const ::std::os::raw::c_char,
        value: *mut ::std::os::raw::c_int,
    ) -> LIPCcode {
        (self
            .LipcHasharrayGetInt
            .as_ref()
            .expect("Expected function, got error."))(ha, index, key, value)
    }
    #[doc = " Put the integer value into the hash map of the hash-array data structure.\n\n @param ha The LIPC hash-array handler.\n @param index The 0-based index in the array.\n @param key The key name to set.\n @param value The value to set.\n @return The status code."]
    pub unsafe fn LipcHasharrayPutInt(
        &self,
        ha: *mut LIPCha,
        index: ::std::os::raw::c_int,
        key: *const ::std::os::raw::c_char,
        value: ::std::os::raw::c_int,
    ) -> LIPCcode {
        (self
            .LipcHasharrayPutInt
            .as_ref()
            .expect("Expected function, got error."))(ha, index, key, value)
    }
    #[doc = " Get the string value form the hash map of the hash-array data structure.\n\n @param ha The LIPC hash-array handler.\n @param index The 0-based index in the array.\n @param key The key name to get.\n @param value The address where the pointer to the string will be stored.\n @return The status code."]
    pub unsafe fn LipcHasharrayGetString(
        &self,
        ha: *mut LIPCha,
        index: ::std::os::raw::c_int,
        key: *const ::std::os::raw::c_char,
        value: *mut *mut ::std::os::raw::c_char,
    ) -> LIPCcode {
        (self
            .LipcHasharrayGetString
            .as_ref()
            .expect("Expected function, got error."))(ha, index, key, value)
    }
    #[doc = " Put the string value into the hash map of the hash-array data structure.\n\n @param ha The LIPC hash-array handler.\n @param index The 0-based index in the array.\n @param key The key name to set.\n @param value The value to set.\n @return The status code."]
    pub unsafe fn LipcHasharrayPutString(
        &self,
        ha: *mut LIPCha,
        index: ::std::os::raw::c_int,
        key: *const ::std::os::raw::c_char,
        value: *const ::std::os::raw::c_char,
    ) -> LIPCcode {
        (self
            .LipcHasharrayPutString
            .as_ref()
            .expect("Expected function, got error."))(ha, index, key, value)
    }
    #[doc = " Get the blob data from the hash map of the hash-array data structure.\n\n @param ha The LIPC hash-array handler.\n @param index The 0-based index in the array.\n @param key The key name to get.\n @param data The address where the pointer to the data will be stored.\n @param size The address where the size of the data will be stored.\n @return The status code."]
    pub unsafe fn LipcHasharrayGetBlob(
        &self,
        ha: *mut LIPCha,
        index: ::std::os::raw::c_int,
        key: *const ::std::os::raw::c_char,
        data: *mut *mut ::std::os::raw::c_uchar,
        size: *mut usize,
    ) -> LIPCcode {
        (self
            .LipcHasharrayGetBlob
            .as_ref()
            .expect("Expected function, got error."))(ha, index, key, data, size)
    }
    #[doc = " Put the blob data into the hash map of the hash-array data structure.\n\n @param ha The LIPC hash-array handler.\n @param index The 0-based index in the array.\n @param key The key name to set.\n @param data The data to set.\n @param size The size of the data.\n @return The status code."]
    pub unsafe fn LipcHasharrayPutBlob(
        &self,
        ha: *mut LIPCha,
        index: ::std::os::raw::c_int,
        key: *const ::std::os::raw::c_char,
        data: *const ::std::os::raw::c_uchar,
        size: usize,
    ) -> LIPCcode {
        (self
            .LipcHasharrayPutBlob
            .as_ref()
            .expect("Expected function, got error."))(ha, index, key, data, size)
    }
    #[doc = " Copy a hash-array data structure.\n\n The destination hash-array structure handler has to be initialized with the\n LipcHasharrayNew() function.\n\n @param dest The destination hash-array handler.\n @param src The source hash-array handler.\n @return The status code."]
    pub unsafe fn LipcHasharrayCopy(&self, dest: *mut LIPCha, src: *const LIPCha) -> LIPCcode {
        (self
            .LipcHasharrayCopy
            .as_ref()
            .expect("Expected function, got error."))(dest, src)
    }
    #[doc = " Copy a single hash map of the hash-array data structure.\n\n The destination hash-array structure handler has to be initialized with the\n LipcHasharrayNew() function.\n\n @param dest The destination hash-array handler.\n @param dest_index The index in the destination hash-array structure, where\n   the copied hash map will be placed.\n @param src The source hash-array handler.\n @param src_index The index within the source hash-array structure, from\n   where the hash map is copied.\n @return The status code."]
    pub unsafe fn LipcHasharrayCopyHash(
        &self,
        dest: *mut LIPCha,
        dest_index: ::std::os::raw::c_int,
        src: *const LIPCha,
        src_index: ::std::os::raw::c_int,
    ) -> LIPCcode {
        (self
            .LipcHasharrayCopyHash
            .as_ref()
            .expect("Expected function, got error."))(dest, dest_index, src, src_index)
    }
    #[doc = " Clone a hash-array data structure.\n\n This function is (almost) an equivalent of calling the LipcHasharrayCopy()\n function using a newly initialized hash-array handler. However, using this\n function ensures, that the internal hash-array key and few other internal\n fields are copied too. The exact meaning of these fields is unknown.\n\n @param ha The hash-array handler to the structure which should be cloned.\n @return On success the LIPC hash-array handler to the new data structure\n   is returned. Upon error this function returns NULL."]
    pub unsafe fn LipcHasharrayClone(&self, ha: *const LIPCha) -> *mut LIPCha {
        (self
            .LipcHasharrayClone
            .as_ref()
            .expect("Expected function, got error."))(ha)
    }
    #[doc = " Save hash-array memory into the given file descriptor.\n\n @param ha The hash-array handler.\n @param fd Opened file descriptor with the write permission.\n @return The status code."]
    pub unsafe fn LipcHasharraySave(
        &self,
        ha: *const LIPCha,
        fd: ::std::os::raw::c_int,
    ) -> LIPCcode {
        (self
            .LipcHasharraySave
            .as_ref()
            .expect("Expected function, got error."))(ha, fd)
    }
    #[doc = " Restore hash-array form the memory read from the given file descriptor.\n\n @param lipc LIPC library handler.\n @param fd Opened file descriptor with the read permission.\n @return On success the LIPC hash-array handler to the restored data\n   structure is returned. Upon error this function returns NULL."]
    pub unsafe fn LipcHasharrayRestore(
        &self,
        lipc: *mut LIPC,
        fd: ::std::os::raw::c_int,
    ) -> *mut LIPCha {
        (self
            .LipcHasharrayRestore
            .as_ref()
            .expect("Expected function, got error."))(lipc, fd)
    }
    #[doc = " Get string representation of the given hash-array.\n\n In order to determine the number of bytes required to store the string\n representation of the given hash-array data structure, one should call this\n function with the size parameter initialized to 0. The number of required\n bytes will be returned back in this parameter - in fact the size parameter\n is always modified, and the number of required bytes is returned in it (be\n careful when reusing this variable).\n\n @param ha The hash-array handler.\n @param str The pointer to the address, where the hash-array string\n   representation will be stored.\n @param size The pointer to the address, where the size of the str buffer\n   is passed. On return, the number of actually used bytes will be stored\n   at this address.\n @return The status code."]
    pub unsafe fn LipcHasharrayToString(
        &self,
        ha: *const LIPCha,
        str_: *mut ::std::os::raw::c_char,
        size: *mut usize,
    ) -> LIPCcode {
        (self
            .LipcHasharrayToString
            .as_ref()
            .expect("Expected function, got error."))(ha, str_, size)
    }
    #[doc = " Get property access timeout.\n\n @note\n The timeout value can be set via the file \"/var/local/system/lipctimeout\",\n otherwise it is set to the default 10000 ms.\n\n @param lipc LIPC library handler.\n @return The timeout value in milliseconds."]
    pub unsafe fn LipcGetPropAccessTimeout(&self, lipc: *mut LIPC) -> ::std::os::raw::c_int {
        (self
            .LipcGetPropAccessTimeout
            .as_ref()
            .expect("Expected function, got error."))(lipc)
    }
    #[doc = " Get the value of the integer property.\n\n @param lipc LIPC library handler.\n @param service The service name.\n @param property The property name.\n @param value The address where the integer value will be stored.\n @return The status code."]
    pub unsafe fn LipcGetIntProperty(
        &self,
        lipc: *mut LIPC,
        service: *const ::std::os::raw::c_char,
        property: *const ::std::os::raw::c_char,
        value: *mut ::std::os::raw::c_int,
    ) -> LIPCcode {
        (self
            .LipcGetIntProperty
            .as_ref()
            .expect("Expected function, got error."))(lipc, service, property, value)
    }
    #[doc = " Set the value of the integer property.\n\n @param lipc LIPC library handler.\n @param service The service name.\n @param property The property name.\n @param value The new value to set.\n @return The status code."]
    pub unsafe fn LipcSetIntProperty(
        &self,
        lipc: *mut LIPC,
        service: *const ::std::os::raw::c_char,
        property: *const ::std::os::raw::c_char,
        value: ::std::os::raw::c_int,
    ) -> LIPCcode {
        (self
            .LipcSetIntProperty
            .as_ref()
            .expect("Expected function, got error."))(lipc, service, property, value)
    }
    #[doc = " Get the value of the string property.\n\n The memory for the returned string is allocated internally by the library\n and should be freed with the LipcFreeString().\n\n @param lipc LIPC library handler.\n @param service The service name.\n @param property The property name.\n @param value The address where the pointer to the string will be stored.\n @return The status code."]
    pub unsafe fn LipcGetStringProperty(
        &self,
        lipc: *mut LIPC,
        service: *const ::std::os::raw::c_char,
        property: *const ::std::os::raw::c_char,
        value: *mut *mut ::std::os::raw::c_char,
    ) -> LIPCcode {
        (self
            .LipcGetStringProperty
            .as_ref()
            .expect("Expected function, got error."))(lipc, service, property, value)
    }
    #[doc = " Set the value of the string property.\n\n @param lipc LIPC library handler.\n @param service The service name.\n @param property The property name.\n @param value The new value to set.\n @return The status code."]
    pub unsafe fn LipcSetStringProperty(
        &self,
        lipc: *mut LIPC,
        service: *const ::std::os::raw::c_char,
        property: *const ::std::os::raw::c_char,
        value: *const ::std::os::raw::c_char,
    ) -> LIPCcode {
        (self
            .LipcSetStringProperty
            .as_ref()
            .expect("Expected function, got error."))(lipc, service, property, value)
    }
    #[doc = " Access the value of the hash-array property.\n\n @param lipc LIPC library handler.\n @param service The service name.\n @param property The property name.\n @param ha An input LIPC hash-array handler or NULL if there is no input.\n @param ha_out The pointer to the address, where the output hash-array\n   handler will be stored. If the output value is not desired, one can\n   pass NULL value in this parameter.\n @return The status code."]
    pub unsafe fn LipcAccessHasharrayProperty(
        &self,
        lipc: *mut LIPC,
        service: *const ::std::os::raw::c_char,
        property: *const ::std::os::raw::c_char,
        ha: *const LIPCha,
        ha_out: *mut *mut LIPCha,
    ) -> LIPCcode {
        (self
            .LipcAccessHasharrayProperty
            .as_ref()
            .expect("Expected function, got error."))(lipc, service, property, ha, ha_out)
    }
    #[doc = " Free memory allocated by the LIPC.\n\n @param string The string pointer."]
    pub unsafe fn LipcFreeString(&self, string: *mut ::std::os::raw::c_char) {
        (self
            .LipcFreeString
            .as_ref()
            .expect("Expected function, got error."))(string)
    }
    #[doc = " Register new integer property.\n\n The access mode of the property is determined by the presence of the getter\n and/or the setter callback function. Passing NULL value in the getter and\n the setter parameters will make the property read-only, however it will not\n be possible to retrieve any value, so it is pointless to do so.\n\n @param lipc LIPC library handler.\n @param property The property name.\n @param getter Getter callback if property is readable.\n @param setter Setter callback if property is writable.\n @param data Data pointer passed to the callback function.\n @return The status code."]
    pub unsafe fn LipcRegisterIntProperty(
        &self,
        lipc: *mut LIPC,
        property: *const ::std::os::raw::c_char,
        getter: LipcPropCallback,
        setter: LipcPropCallback,
        data: *mut ::std::os::raw::c_void,
    ) -> LIPCcode {
        (self
            .LipcRegisterIntProperty
            .as_ref()
            .expect("Expected function, got error."))(lipc, property, getter, setter, data)
    }
    #[doc = " Register new string property.\n\n For the information about the property access mode, see the documentation\n of the LipcRegisterIntProperty().\n\n @param lipc LIPC library handler.\n @param property The property name.\n @param getter Getter callback if property is readable.\n @param setter Setter callback if property is writable.\n @param data Data pointer passed to the callback function.\n @return The status code."]
    pub unsafe fn LipcRegisterStringProperty(
        &self,
        lipc: *mut LIPC,
        property: *const ::std::os::raw::c_char,
        getter: LipcPropCallback,
        setter: LipcPropCallback,
        data: *mut ::std::os::raw::c_void,
    ) -> LIPCcode {
        (self
            .LipcRegisterStringProperty
            .as_ref()
            .expect("Expected function, got error."))(lipc, property, getter, setter, data)
    }
    #[doc = " Register new hash-array property.\n\n @param lipc LIPC library handler.\n @param property The property name.\n @param callback Getter and setter callback function.\n @param data Data pointer passed to the callback function.\n @return The status code."]
    pub unsafe fn LipcRegisterHasharrayProperty(
        &self,
        lipc: *mut LIPC,
        property: *const ::std::os::raw::c_char,
        callback: LipcPropCallback,
        data: *mut ::std::os::raw::c_void,
    ) -> LIPCcode {
        (self
            .LipcRegisterHasharrayProperty
            .as_ref()
            .expect("Expected function, got error."))(lipc, property, callback, data)
    }
    #[doc = " Unregister property.\n\n If the data parameter is not NULL, the address of the data pointer passed\n during the property registration will be stored in the address pointed by\n the *data.\n\n @param lipc LIPC library handler.\n @param property The property name.\n @param data Address where the data pointer is returned.\n @return The status code."]
    pub unsafe fn LipcUnregisterProperty(
        &self,
        lipc: *mut LIPC,
        property: *const ::std::os::raw::c_char,
        data: *mut *mut ::std::os::raw::c_void,
    ) -> LIPCcode {
        (self
            .LipcUnregisterProperty
            .as_ref()
            .expect("Expected function, got error."))(lipc, property, data)
    }
    #[doc = " Create a new event object.\n\n In order to use this function the LIPC handler has to be opened with the\n service name given using LipcOpen() or LipcOpenEx().\n\n @param lipc LIPC library handler.\n @param name The event name.\n @return On success the LIPCevent handler is returned, which should be freed\n   with the LipcEventFree(). Upon error this function returns NULL."]
    pub unsafe fn LipcNewEvent(
        &self,
        lipc: *mut LIPC,
        name: *const ::std::os::raw::c_char,
    ) -> *mut LIPCevent {
        (self
            .LipcNewEvent
            .as_ref()
            .expect("Expected function, got error."))(lipc, name)
    }
    #[doc = " Free memory allocated by the LIPC.\n\n @param event LIPC event handler."]
    pub unsafe fn LipcEventFree(&self, event: *mut LIPCevent) {
        (self
            .LipcEventFree
            .as_ref()
            .expect("Expected function, got error."))(event)
    }
    #[doc = " Send event object.\n\n @param lipc LIPC library handler.\n @param event LIPC event handler.\n @return The status code."]
    pub unsafe fn LipcSendEvent(&self, lipc: *mut LIPC, event: *mut LIPCevent) -> LIPCcode {
        (self
            .LipcSendEvent
            .as_ref()
            .expect("Expected function, got error."))(lipc, event)
    }
    #[doc = " Create and send event.\n\n This function is an equivalent of using LipcNewEvent(), LipcSendEvent() and\n LipcEventFree() all together. If you want to send a simple event object -\n one without any parameters - use this function.\n\n @param lipc LIPC library handler.\n @param name The event name.\n @return The status code."]
    pub unsafe fn LipcCreateAndSendEvent(
        &self,
        lipc: *mut LIPC,
        name: *const ::std::os::raw::c_char,
    ) -> LIPCcode {
        (self
            .LipcCreateAndSendEvent
            .as_ref()
            .expect("Expected function, got error."))(lipc, name)
    }
    #[doc = " Create and send event.\n\n This function creates an event object and sets its parameters according to\n the format string. Parameter values should be passed as a variable argument\n list. For the list of all supported formats, see the documentation of the\n LipcCreateAndSendEventWithParameters() function.\n\n @param lipc LIPC library handler.\n @param name The event name.\n @param format The format string.\n @param ap Variable argument list.\n @return The status code."]
    pub unsafe fn LipcCreateAndSendEventWithVAListParameters(
        &self,
        lipc: *mut LIPC,
        name: *const ::std::os::raw::c_char,
        format: *const ::std::os::raw::c_char,
        ap: va_list,
    ) -> LIPCcode {
        (self
            .LipcCreateAndSendEventWithVAListParameters
            .as_ref()
            .expect("Expected function, got error."))(lipc, name, format, ap)
    }
    #[doc = " Get the source name associated with the event.\n\n @param event LIPC event handler.\n @return The source name from where the event originates."]
    pub unsafe fn LipcGetEventSource(
        &self,
        event: *mut LIPCevent,
    ) -> *const ::std::os::raw::c_char {
        (self
            .LipcGetEventSource
            .as_ref()
            .expect("Expected function, got error."))(event)
    }
    #[doc = " Get the name of the event.\n\n @param event LIPC event handler.\n @return The event name."]
    pub unsafe fn LipcGetEventName(&self, event: *mut LIPCevent) -> *const ::std::os::raw::c_char {
        (self
            .LipcGetEventName
            .as_ref()
            .expect("Expected function, got error."))(event)
    }
    #[doc = " Get the integer parameter from the event.\n\n @param event LIPC event handler.\n @param value The address where the integer value will be stored.\n @return The status code."]
    pub unsafe fn LipcGetIntParam(
        &self,
        event: *mut LIPCevent,
        value: *mut ::std::os::raw::c_int,
    ) -> LIPCcode {
        (self
            .LipcGetIntParam
            .as_ref()
            .expect("Expected function, got error."))(event, value)
    }
    #[doc = " Add the integer parameter to the event.\n\n @param event LIPC event handler.\n @param value The new value to add.\n @return The status code."]
    pub unsafe fn LipcAddIntParam(
        &self,
        event: *mut LIPCevent,
        value: ::std::os::raw::c_int,
    ) -> LIPCcode {
        (self
            .LipcAddIntParam
            .as_ref()
            .expect("Expected function, got error."))(event, value)
    }
    #[doc = " Get the string parameter from the event.\n\n @note\n The obtained memory pointer should not be passed to the LipcFreeString()\n function. It seems, that the memory is managed internally by the library.\n\n @param event LIPC event handler.\n @param value The address where the pointer to the string will be stored.\n @return The status code."]
    pub unsafe fn LipcGetStringParam(
        &self,
        event: *mut LIPCevent,
        value: *mut *mut ::std::os::raw::c_char,
    ) -> LIPCcode {
        (self
            .LipcGetStringParam
            .as_ref()
            .expect("Expected function, got error."))(event, value)
    }
    #[doc = " Add the string parameter to the event.\n\n @param event LIPC event handler.\n @param value The new value to add.\n @return The status code."]
    pub unsafe fn LipcAddStringParam(
        &self,
        event: *mut LIPCevent,
        value: *const ::std::os::raw::c_char,
    ) -> LIPCcode {
        (self
            .LipcAddStringParam
            .as_ref()
            .expect("Expected function, got error."))(event, value)
    }
    #[doc = " Rewind parameters of the event.\n\n @param event LIPC event handler.\n @return The status code."]
    pub unsafe fn LipcRewindParams(&self, event: *mut LIPCevent) -> LIPCcode {
        (self
            .LipcRewindParams
            .as_ref()
            .expect("Expected function, got error."))(event)
    }
    #[doc = " Set default event callback function.\n\n The callback function will be called when one uses the LipcSubscribe()\n subscription mechanism. Note, that it is not possible to pass user-defined\n data via this approach - if one wants to pass extra data to the callback\n function, one should use the LipcSubscribeExt() instead.\n\n @param lipc LIPC library handler.\n @param callback Event dispatching callback function.\n @return The status code."]
    pub unsafe fn LipcSetEventCallback(
        &self,
        lipc: *mut LIPC,
        callback: LipcEventCallback,
    ) -> LIPCcode {
        (self
            .LipcSetEventCallback
            .as_ref()
            .expect("Expected function, got error."))(lipc, callback)
    }
    #[doc = " Subscribe for all events emitted by the service.\n\n In order to receive event notifications, one has to set default callback\n function using the LipcSetEventCallback() function. Using them both, is an\n equivalent of using the extended version with parameters set as follows:\n LipcSubscribeExt(lipc, service, NULL, callback, NULL)\n\n @param lipc LIPC library handler.\n @param service The service name.\n @return The status code."]
    pub unsafe fn LipcSubscribe(
        &self,
        lipc: *mut LIPC,
        service: *const ::std::os::raw::c_char,
    ) -> LIPCcode {
        (self
            .LipcSubscribe
            .as_ref()
            .expect("Expected function, got error."))(lipc, service)
    }
    #[doc = " Subscribe for events emitted by the service.\n\n This function is an extended version of the LipcSubscribe(), which allows\n to set the event name for which one wants to subscribe and the user-defined\n data passed to the callback function. Passing NULL instead of the event\n name will subscribe for all events.\n\n @param lipc LIPC library handler.\n @param service The service name.\n @param name The event name.\n @param callback Event dispatching callback function.\n @param data Data pointer passed to the callback function.\n @return The status code."]
    pub unsafe fn LipcSubscribeExt(
        &self,
        lipc: *mut LIPC,
        service: *const ::std::os::raw::c_char,
        name: *const ::std::os::raw::c_char,
        callback: LipcEventCallback,
        data: *mut ::std::os::raw::c_void,
    ) -> LIPCcode {
        (self
            .LipcSubscribeExt
            .as_ref()
            .expect("Expected function, got error."))(lipc, service, name, callback, data)
    }
    #[doc = " Unsubscribe from event or events.\n\n If the event name is NULL, this function will unsubscribe from events\n delivered to the callback set with the LipcSetEventCallback().\n\n @param lipc LIPC library handler.\n @param service The service name.\n @param name The event name or NULL.\n @param data Address where the data pointer is returned or NULL.\n @return The status code."]
    pub unsafe fn LipcUnsubscribeExt(
        &self,
        lipc: *mut LIPC,
        service: *const ::std::os::raw::c_char,
        name: *const ::std::os::raw::c_char,
        data: *mut *mut ::std::os::raw::c_void,
    ) -> LIPCcode {
        (self
            .LipcUnsubscribeExt
            .as_ref()
            .expect("Expected function, got error."))(lipc, service, name, data)
    }
    pub unsafe fn g_lab126_log_mask(&self) -> *mut ::std::os::raw::c_int {
        *self
            .g_lab126_log_mask
            .as_ref()
            .expect("Expected variable, got error.")
    }
    #[doc = " Set the LIPC internal logging mask.\n\n The logging mask parameter should be the logical OR of the logging flags\n (LAB126_LOG_* definitions). The current state of the logging mask can be\n accessed via the g_lab126_log_mask global variable.\n\n @param mask The logging mask."]
    pub unsafe fn LipcSetLlog(&self, mask: ::std::os::raw::c_int) {
        (self
            .LipcSetLlog
            .as_ref()
            .expect("Expected function, got error."))(mask)
    }
}
